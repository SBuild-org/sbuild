import de.tototec.sbuild._
import de.tototec.sbuild.ant._
import de.tototec.sbuild.ant.tasks._
import de.tototec.sbuild.TargetRefs._

@version("0.3.2")
@include(
  "../SBuildConfig.scala",
  "../de.tototec.sbuild.addons/src/main/scala/de/tototec/sbuild/addons/scala/Scaladoc.scala",
  "../de.tototec.sbuild.addons/src/main/scala/de/tototec/sbuild/addons/support/ForkSupport.scala"
)
@classpath("mvn:org.apache.ant:ant:1.8.4") 
class SBuild(implicit _project: Project) {

  val jar = s"target/de.tototec.sbuild-${SBuildConfig.sbuildVersion}.jar"
  val sourcesZip = s"target/de.tototec.sbuild-${SBuildConfig.sbuildVersion}-sources.jar"

  val compileCp =
    s"mvn:org.scala-lang:scala-library:${SBuildConfig.scalaVersion}" ~
      "http://repo.fusesource.com/nexus/content/groups/public/org/fusesource/jansi/jansi/1.9/jansi-1.9.jar" ~
      SBuildConfig.cmdOptionSource

  val testCp = compileCp ~
      s"mvn:org.scalatest:scalatest_${SBuildConfig.scalaBinVersion}:1.9.1" ~
      s"mvn:org.scala-lang:scala-actors:${SBuildConfig.scalaVersion}"

  ExportDependencies("eclipse.classpath", testCp)

  Target("phony:all") dependsOn jar ~ sourcesZip ~ "test"

  val versionScalaFile = "target/generated-scala/scala/de/tototec/sbuild/SBuildVersion.scala"

  Target("phony:clean") exec {
    AntDelete(dir = Path("target"))
  }

  Target(versionScalaFile) dependsOn "../SBuildConfig.scala" exec { ctx: TargetContext =>
    AntMkdir(dir = ctx.targetFile.get.getParentFile)
    AntEcho(message = s"Generating versions file for version: ${SBuildConfig.sbuildVersion} / ${SBuildConfig.sbuildOsgiVersion}")
    AntEcho(file = ctx.targetFile.get, message = s"""// Generated by SBuild from file SBuild.scala
package de.tototec.sbuild

object SBuildVersion {
  def version = "${SBuildConfig.sbuildVersion}"
  def osgiVersion = "${SBuildConfig.sbuildOsgiVersion}" 
}
""")
  }

  def validateGeneratedVersions(deps: Seq[java.io.File]) {
    // validate versions
    val cl = new java.net.URLClassLoader(
      (Seq(Path("target/classes").toURI.toURL) ++ deps.map(_.toURI.toURL)).toArray,
      null)
    val versionClass = cl.loadClass("de.tototec.sbuild.SBuildVersion")
    val readVersion = versionClass.getMethod("version").invoke(null)
    val readOsgiVersion = versionClass.getMethod("osgiVersion").invoke(null)
    if (readVersion != SBuildConfig.sbuildVersion || readOsgiVersion != SBuildConfig.sbuildOsgiVersion) {
      throw new Exception(s"Versions in SBuildVersion class do not match current values! read version: ${readVersion} , read osgiVersion: ${readOsgiVersion}")
    } else {
      AntEcho(message = "Versions match")
    }
  }

  Target("phony:compile") dependsOn SBuildConfig.compilerPath ~ compileCp ~ versionScalaFile exec { ctx: TargetContext =>
    val output = "target/classes"
    AntMkdir(dir = Path(output))
    IfNotUpToDate(Seq(Path("src/main/scala"), Path("src/main/java"), Path("target/generated-scala")), Path("target"), ctx) {
      // compile scala files (compiler will also see java files)

      val compilerFilter = """.*scala-((library)|(compiler)|(reflect)).*""".r

      compileScala(
        compilerClasspath = ctx.fileDependencies.filter(f => compilerFilter.pattern.matcher(f.getName).matches),
        srcDirs = Seq("src/main/scala", "src/main/java", "target/generated-scala"),
        destDir = output,
        classpath = ctx.fileDependencies
      )

      // compile java files
      AntJavac(
        srcDir = AntPath("src/main/java"),
        destDir = Path(output),
        classpath = AntPath(locations = ctx.fileDependencies),
        fork = true,
        source = "1.6",
        target = "1.6",
        encoding = "UTF-8",
        debug = true,
        includeAntRuntime = false)

    }

    // re-enable when used SBuild version used Scala 2.10
    // validateGeneratedVersions(ctx.fileDependencies)
  }

  Target("phony:checkResources") exec { ctx: TargetContext =>
    IfNotUpToDate(Path("src/main/resources"), Path("target"), ctx) {}
  }

  Target("phony:checkMainSources") exec { ctx: TargetContext =>
    IfNotUpToDate(Seq(Path("src/main"), Path("target/generated-scala")), Path("target"), ctx) {}
  }

  Target("phony:checkScalaSources") exec { ctx: TargetContext =>
    IfNotUpToDate(Seq(Path("src/main/scala"), Path("target/generated-scala")), Path("target"), ctx) {}
  }

  Target(jar) dependsOn "compile" ~ "checkResources" exec { ctx: TargetContext =>
    new AntJar(destFile = ctx.targetFile.get, baseDir = Path("target/classes")) {
      if (Path("src/main/resources").exists) add(AntFileSet(dir = Path("src/main/resources")))
      add(AntFileSet(file = Path("LICENSE.txt")))
    }.execute
  }

  Target(sourcesZip) dependsOn versionScalaFile ~ "checkMainSources" exec { ctx: TargetContext =>
    AntZip(destFile = ctx.targetFile.get, fileSets = Seq(
      AntFileSet(dir = Path("src/main/scala")),
      AntFileSet(dir = Path("src/main/java")),
      AntFileSet(dir = Path("src/main/resources")),
      AntFileSet(dir = Path("target/generated-scala")),
      AntFileSet(file = Path("LICENSE.txt"))
    ))
  }

//   Target("phony:scaladoc") dependsOn compileCp ~ "checkScalaSources" exec { ctx: TargetContext =>
//     AntMkdir(dir = Path("target/scaladoc"))
//     scala_tools_ant.AntScaladoc(
//       deprecation = "on",
//       unchecked = "on",
//       classpath = AntPath(locations = ctx.fileDependencies),
//       srcDir = AntPath(path = "src/main/scala"),
//       destDir = Path("target/scaladoc"))
//   }

  Target("phony:testCompile") dependsOn SBuildConfig.compilerPath ~ testCp ~ jar exec { ctx: TargetContext =>
    IfNotUpToDate(Path("src/test/scala"), Path("target"), ctx) {
      AntMkdir(dir = Path("target/test-classes"))
      compileScala(
        compilerClasspath = ctx.fileDependencies.filter(f => f.getName.contains("scala")),
        srcDirs = Seq("src/test/scala"),
        destDir = "target/test-classes",
        classpath = ctx.fileDependencies
      )
    }
  }

  Target("phony:test") dependsOn testCp ~ jar ~ "testCompile" exec { ctx: TargetContext =>
    de.tototec.sbuild.addons.scalatest.ScalaTest(
      classpath = ctx.fileDependencies,
      runPath = Seq("target/test-classes"),
      reporter = "oF",
      fork = true)
  }

  def compileScala(compilerClasspath: Seq[java.io.File],
                   classpath: Seq[java.io.File],
                   destDir: String = "target/classes",
                   srcDirs: Seq[String] = Seq("src/main/scala")) {

    new addons.scala.Scalac(
      compilerClasspath = compilerClasspath,
      srcDirs = srcDirs.map(d => Path(d)),
      destDir = Path(destDir),
      classpath = classpath,
      deprecation = true,
      unchecked = true,
      debugInfo = "vars",
      target = "jvm-1.6",
      fork = true
    ).execute
  }

  Target("phony:scaladoc") dependsOn SBuildConfig.compilerPath ~ compileCp ~ "checkScalaSources" ~ versionScalaFile exec {
    addons.scala.Scaladoc(
      scaladocClasspath = SBuildConfig.compilerPath.files,
      classpath = compileCp.files,
      srcDirs = Seq(Path("src/main/scala"), Path("target/generated-scala")) ,
      destDir = Path("target/scaladoc"),
      deprecation = true, unchecked = true, implicits = true
    )
  }

}
