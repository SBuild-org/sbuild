import de.tototec.sbuild._
import de.tototec.sbuild.ant._
import de.tototec.sbuild.ant.tasks._
import de.tototec.sbuild.TargetRefs._

// classpath
//   "http://repo1.maven.org/maven2/org/apache/ant/ant-launcher/1.8.3/ant-launcher-1.8.3.jar",
//   "http://repo1.maven.org/maven2/junit/junit/4.10/junit-4.10.jar"
@version("0.2.0")
@include(
  "../SBuildConfig.scala",
  "../de.tototec.sbuild.addons/src/main/scala/de/tototec/sbuild/addons/support/ForkSupport.scala",
  "../de.tototec.sbuild.addons/src/main/scala/de/tototec/sbuild/addons/scala/Scalac.scala",
  "../de.tototec.sbuild.addons/src/main/scala/de/tototec/sbuild/addons/scalatest/ScalaTest.scala"
)
@classpath(
  "http://repo1.maven.org/maven2/org/apache/ant/ant/1.8.3/ant-1.8.3.jar"
) 
class SBuild(implicit _project: Project) {

  SchemeHandler("http", new HttpSchemeHandler(Path(".sbuild/http")))
  SchemeHandler("mvn", new MvnSchemeHandler())

  val jar = "target/de.tototec.sbuild-" + SBuildConfig.sbuildVersion + ".jar"
  val sourcesZip = "target/de.tototec.sbuild-" + SBuildConfig.sbuildVersion + "-sources.jar"

  val compileCp =
    ("mvn:org.scala-lang:scala-library:" + SBuildConfig.scalaVersion) ~
      SBuildConfig.cmdOptionSource

  val scalaTestCp = if(SBuildConfig.scalaBinVersion.startsWith("2.9")) {
      ("mvn:org.scalatest:scalatest_" + SBuildConfig.scalaBinVersion + ":1.9.1")
    } else {
      ("mvn:org.scalatest:scalatest_" + SBuildConfig.scalaBinVersion + ":1.9.1") ~
      ("mvn:org.scala-lang:scala-actors:" + SBuildConfig.scalaVersion)
  }

  val testCp = compileCp ~ scalaTestCp

  ExportDependencies("eclipse.classpath", testCp)

  Target("phony:all") dependsOn jar ~ sourcesZip ~ "test"

  val versionScalaFile = "target/generated-scala/scala/de/tototec/sbuild/SBuildVersion.scala"

  Target("phony:clean") exec {
    AntDelete(dir = Path("target"))
  }

  Target(versionScalaFile) dependsOn "../SBuildConfig.scala" exec { ctx: TargetContext =>
    AntMkdir(dir = ctx.targetFile.get.getParentFile)
    AntEcho(message = "Generating versions file for version: " + SBuildConfig.sbuildVersion + " / " + SBuildConfig.sbuildOsgiVersion)
    AntEcho(file = ctx.targetFile.get, message = """// Generated by SBuild from file SBuild.scala
package de.tototec.sbuild

object SBuildVersion {
  def version = """" + SBuildConfig.sbuildVersion + """"
  def osgiVersion = """" + SBuildConfig.sbuildOsgiVersion + """" 
}
""")
  }

  def validateGeneratedVersions(deps: Seq[java.io.File]) {
    // validate versions
    val cl = new java.net.URLClassLoader(
      (Seq(Path("target/classes").toURI.toURL) ++ deps.map(_.toURI.toURL)).toArray,
      null)
    val versionClass = cl.loadClass("de.tototec.sbuild.SBuildVersion")
    val readVersion = versionClass.getMethod("version").invoke(null)
    val readOsgiVersion = versionClass.getMethod("osgiVersion").invoke(null)
    if (readVersion != SBuildConfig.sbuildVersion || readOsgiVersion != SBuildConfig.sbuildOsgiVersion) {
      throw new Exception("Versions in SBuildVersion class do not match current values! read version: " +
        readVersion + ", read osgiVersion: " + readOsgiVersion)
    } else {
      AntEcho(message = "Versions match")
    }
  }

  //   def antScalac = new scala_tools_ant.AntScalac(
  //     target = "jvm-1.5",
  //     encoding = "UTF-8",
  //     deprecation = "on",
  //     unchecked = "on",
  //     debugInfo = "vars",
  //     // this is necessary, because the scala ant tasks outsmarts itself 
  //     // when more than one scala class is defined in the same .scala file
  //     force = true)

  //   Target("phony:old-compile") dependsOn compileCp ~ versionScalaFile exec { ctx: TargetContext =>
  //     val output = "target/classes"
  //     AntMkdir(dir = Path(output))
  //     IfNotUpToDate(Seq(Path("src/main/scala"), Path("src/main/java"), Path("target/generated-scala")), Path("target"), ctx) {
  //       // compile scala files (compiler will also see java files
  //       val scalac = antScalac
  //       scalac.setSrcDir(AntPath(paths = Seq("src/main/scala", "src/main/java", "target/generated-scala")))
  //       scalac.setDestDir(Path(output))
  //       scalac.setClasspath(AntPath(locations = ctx.fileDependencies))
  //       scalac.execute
  // 
  //       // compile java files
  //       AntJavac(
  //         srcDir = AntPath("src/main/java"),
  //         destDir = Path("target/classes"),
  //         classpath = AntPath(locations = ctx.fileDependencies),
  //         fork = true,
  //         source = "1.5",
  //         target = "1.5",
  //         encoding = "UTF-8",
  //         debug = true,
  //         includeAntRuntime = false)
  //     }
  // 
  //     validateGeneratedVersions(ctx.fileDependencies)
  //   }

  Target("phony:compile") dependsOn SBuildConfig.compilerPath ~ compileCp ~ versionScalaFile exec { ctx: TargetContext =>
    val output = "target/classes"
    AntMkdir(dir = Path(output))
    IfNotUpToDate(Seq(Path("src/main/scala"), Path("src/main/java"), Path("target/generated-scala")), Path("target"), ctx) {
      // compile scala files (compiler will also see java files)

      val compilerFilter = """.*scala-((library)|(compiler)|(reflect)).*""".r

      compileScala(
        compilerClasspath = ctx.fileDependencies.filter(f => compilerFilter.pattern.matcher(f.getName).matches),
        srcDirs = Seq("src/main/scala", "src/main/java", "target/generated-scala"),
        destDir = output,
        classpath = ctx.fileDependencies
      )

      // compile java files
      AntJavac(
        srcDir = AntPath("src/main/java"),
        destDir = Path(output),
        classpath = AntPath(locations = ctx.fileDependencies),
        fork = true,
        source = "1.5",
        target = "1.5",
        encoding = "UTF-8",
        debug = true,
        includeAntRuntime = false)

    }
  }

  Target("phony:checkResources") exec { ctx: TargetContext =>
    IfNotUpToDate(Path("src/main/resources"), Path("target"), ctx) {}
  }

  Target("phony:checkMainSources") exec { ctx: TargetContext =>
    IfNotUpToDate(Seq(Path("src/main"), Path("target/generated-scala")), Path("target"), ctx) {}
  }

  Target("phony:checkScalaSources") exec { ctx: TargetContext =>
    IfNotUpToDate(Seq(Path("src/main/scala"), Path("target/generated-scala")), Path("target"), ctx) {}
  }

  Target(jar) dependsOn "compile" ~ "checkResources" exec { ctx: TargetContext =>
    new AntJar(destFile = ctx.targetFile.get, baseDir = Path("target/classes")) {
      if (Path("src/main/resources").exists) add(AntFileSet(dir = Path("src/main/resources")))
      add(AntFileSet(file = Path("LICENSE.txt")))
    }.execute
  }

  Target(sourcesZip) dependsOn versionScalaFile ~ "checkMainSources" exec { ctx: TargetContext =>
    AntZip(destFile = ctx.targetFile.get, fileSets = Seq(
      AntFileSet(dir = Path("src/main/scala")),
      AntFileSet(dir = Path("src/main/java")),
      AntFileSet(dir = Path("src/main/resources")),
      AntFileSet(dir = Path("target/generated-scala")),
      AntFileSet(file = Path("LICENSE.txt"))
    ))
  }

//   Target("phony:scaladoc") dependsOn compileCp ~ "checkScalaSources" exec { ctx: TargetContext =>
//     AntMkdir(dir = Path("target/scaladoc"))
//     scala_tools_ant.AntScaladoc(
//       deprecation = "on",
//       unchecked = "on",
//       classpath = AntPath(locations = ctx.fileDependencies),
//       srcDir = AntPath(path = "src/main/scala"),
//       destDir = Path("target/scaladoc"))
//   }

  Target("phony:testCompile") dependsOn SBuildConfig.compilerPath ~ testCp ~ jar exec { ctx: TargetContext =>
    IfNotUpToDate(Path("src/test/scala"), Path("target"), ctx) {
      AntMkdir(dir = Path("target/test-classes"))
      compileScala(
        compilerClasspath = ctx.fileDependencies.filter(f => f.getName.contains("scala")),
        srcDirs = Seq("src/test/scala"),
        destDir = "target/test-classes",
        classpath = ctx.fileDependencies
      )
    }
  }

  Target("phony:test") dependsOn testCp ~ jar ~ "testCompile" exec { ctx: TargetContext =>
    de.tototec.sbuild.addons.scalatest.ScalaTest(
      classpath = ctx.fileDependencies,
      runPath = Seq("target/test-classes"),
      reporter = "oF",
      fork = true)
  }

  def compileScala(compilerClasspath: Seq[java.io.File],
                   classpath: Seq[java.io.File],
                   destDir: String = "target/classes",
                   srcDirs: Seq[String] = Seq("src/main/scala")) {

    new addons.scala.Scalac(
      compilerClasspath = compilerClasspath,
      srcDirs = srcDirs.map(d => Path(d)),
      destDir = Path(destDir),
      classpath = classpath,
      deprecation = true,
      unchecked = true,
      debugInfo = "vars",
      target = "jvm-1.5",
      fork = true
    ).execute
  }

}
