h2(Usage). Usage

SBuild's main interface is a command line tool called @sbuild@. It supports various options and will receive the targets, you want to build, as parameters. When invoked, it searches for a build file @SBuild.scala@ in the current directory, reads it and executes the requested targets.

h3. Built-in Command Line Help

Here is the built-in usage that you will get, if you invoke  @sbuild@ with the @--help@ option:

bc.. 
bash $ sbuild --help
SBuild 0.3.2 (c) 2011 - 2013, ToToTec GbR, Tobias Roeser

Usage: sbuild [options] [parameter]

Options:
  --additional-buildfile,-F FILE  Add an additional buildfile into scope.
  --buildfile,-f FILE             The buildfile to use (default: SBuild.scala).
  --clean                         Remove all generated output and caches. This
                                  will force a new compile of the buildfile.
                                  (This will not remove output generated by
                                  buildfiles.)
  --create-stub                   Create a new minimal SBuild.scala file to
                                  start with.
  --define,-D KEY=VALUE           Define or override properties. If VALUE is
                                  omitted it defaults to "true".
  --dependency-tree               Show dependency tree(s) and exit.
  --execution-plan                Show the execution plan and exit.
  --fsc                           Use the fast scala compiler (client/server)
  --help,-h                       Show this help screen.
  --list-targets,-l               Show a list of targets defined in the current
                                  buildfile
  --list-targets-recursive,-L     Show a list of targets defined in the current
                                  buildfile and all modules
  --no-fsc                        Do not try to use the fast scala compiler
                                  (client/server)
  -q,--quiet,--no-progress        Quiet mode. Don't show progress messages with
                                  progress in percent. (This will speed up
                                  SBuild initialization.)
  --verbose,-v                    Be verbose when running.
  --version                       Show SBuild version.

Parameter:
  TARGETS  The target(s) to execute (in order).
p. 

h3. The Buildfile

The buildfile contains all instructions and target descriptions and is typically written by the developer.

If @sbuild@ does not found any buildfile, it will stop with an error message like this one:

bc.. 
bash $ sbuild 

SBuild detected a failure in the project configuration or the build scripts.
Details: Project file '/tmp/SBuild.scala' does not exists
p. 

The relevant error message is "Project file '/tmp/SBuild.scala' does not exists" and tells you, that the buildfile "Sbuild.scala" is required to proceed but was not found in the current directory.
p. 

h4. Creating a Buildfile stub

For an easy start you can instruct @sbuild@ to create an minimal template file for you:

bc..  
bash $ sbuild --create-stub
p. 

If you now invoke @sbuild@ again, the error message is gone and sbuild does some things. It will download some required dependencies (because they are listed in the @@classpath@-Annotation) and it compiles the buildfile. Those actions are only necessary the first time after the buildscript has changed.

<pre>
bash $ sbuild
Downloading mvn:org.apache.ant:ant:1.8.4...
Compiling build script /tmp/SBuild.scala...
</pre>

But otherwise it did nothing special. This is because you don't told @sbuild@ what to do. So, you should add at least one target to the commandline. If you dont know, which targets are available you can:
# ask @sbuild@ to show it to you
# look into the buildfile

h4. List all available targets

So first, let's ask @sbuild@ to show all available targets:
<pre>
bash $ sbuild -l
hello   Say hello
</pre>

We see, that one target with the name "hello" is available, and we get even a short description of the purpose of that target.

h4. Buildfile example

Now, let's have a look into the buildfile:
<pre><code class="java">
import de.tototec.sbuild._
import de.tototec.sbuild.TargetRefs._
import de.tototec.sbuild.ant._
import de.tototec.sbuild.ant.tasks._

@version("0.3.2")
@classpath("mvn:org.apache.ant:ant:1.8.4")
class SBuild(implicit _project: Project) {

  Target("phony:hello") help "Say hello" exec {
    AntEcho(message = "Hello!")
  }

}
</code></pre>

Here we see, that exactly one target with the name "phony:hello" is defined. The part after the @exec@ keyword will be executed, when the target needs to run. It contains one action, the [[AntEcho]] task, which is a wrapper around the @echo@ task from Apache Ant.

h4. Execution

So, let's try to execute that target:

bc.. 
bash $ sbuild hello
Calculating dependency tree...
Executing...
[0%] Executing target: hello
Hello!
[100%] Execution finished. SBuild init time: 270 msec, Execution time: 41 msec
p. 

And voila, as expected, it printed the "Hello!" message.

Of course, this is a very trivial example, but a good start to write your own build scripts.

